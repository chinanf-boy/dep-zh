---
title: Migrating to Dep
---
理想情况下,将现有GO项目迁移到DEP是很简单的:

```bash
$ cd $GOPATH/src/path/to/project/root
$ dep init
```

对于许多项目来说,这将是有效的.`dep init`将对你的依赖项使用哪些版本进行有意义的猜测,生成理智.`Gopkg.toml`,`Gopkg.lock`和`vendor/`如果你的测试通过并建立了工作,那么你可能已经完成了.(如果是的话,祝贺你!你应该退房[每日DEP](daily-dep.md)下一步)

一些项目的迁移过程仍然很困难.如果您是第一次尝试dep,这可能会特别令人沮丧,因为您试图同时学习如何使用dep,以及项目如何进行*应该*部门管理,好消息是`dep init`通常是难度很大的驼峰;一旦你超过它,事情就变得容易多了.

本指南的目的是提供足够的信息,让你对发生的事情进行推理.`dep init`这样,你至少可以理解你遇到的是什么样的问题,你可以采取什么步骤来解决这些问题.为此,我们将首先概述一下`dep init`正在做.

> 注:第一次运行`dep init`可能需要相当长的时间,因为DEP正在把你所有的依赖者的新克隆创造成一个特殊的位置,`$GOPATH/pkg/dep/sources/`. 这对于DEP的正常操作是必要的,并且在很大程度上是一次性成本.

## `dep init`力学

迁移现有项目时,首要目标是`dep init`是自动化创建一个`Gopkg.toml`尽可能.这必然是一个启发性的目标,因为DEP对于你之前所做的一切可能没有1:1的对应关系.因此,重要的是只期待`dep init`自动化迁移是在尽力而为的基础上进行的.

行为`dep init`取决于现有代码库中的内容和传递给它的标志.然而,它总是分两个阶段进行:

1.  *推理阶段:*从各种来源推断规则和提示,说明使用哪些版本的依赖项.
2.  *解决阶段:*在DEP的模型下设计一个可以接受的解决方案,同时尽可能多地结合上面的推论.

### 推理阶段

推理阶段是在哪里`dep init`其行为各不相同.默认情况下,`dep init`将查看您的代码库中的元数据文件[其他可以理解的GO包管理工具](https://github.com/golang/dep/tree/master/internal/importers)以及尝试自动将这些文件中的数据迁移到dep中具有意义的概念中.根据工具和dep找到的特定值,可以将来自工具的元数据视为:

-   提示:dep在解决阶段会尽力遵守的信息,但是如果它找不到尊重提示的解决方案,就会丢弃这些信息.
-   规则:在解决阶段必须遵守的信息,最终将出现在`Gopkg.toml`作为一个`[[constraint]]`. 如果解决阶段不能找到满足规则的解决方案,那么它将以信息性消息失败.

有三种情况可以导致DEP不做任何基于工具的推断:

-   您的项目不使用包管理工具
-   DEP还不支持你使用的工具
-   你告诉它不要,通过跑步`dep init -skip-tools`

在基于工具的推理完成之后,DEP通常会进入求解阶段.但是,如果用户通过`-gopath`标记,DEP将首先尝试通过检查当前项目中包含的GopAs来填充从工具元数据中提取的推断中的任何漏洞.只有从GopaTM收集到的提示,它们永远不会取代工具元数据的推断.如果你想把Gopathe完全负责,就通过这两个标志:`dep init -skip-tools -gopath`.

一旦DEP编译了它的推论集,它就开始求解.

### 求解阶段

一旦推理阶段完成,DEP已装配的规则和提示将被传递给它.[求解器](the-solver.md)设计一个传递完整的DePrGrand,最终将被记录为`Gopkg.lock`. 这是相同的求解过程.`dep ensure`并且成功完成它意味着dep已经找到遵守所有推断规则的依赖版本的组合,以及尽可能多的推断提示.如果解决成功,那么努力工作就完成了;剩下的大部分是写出来的.`Gopkg.toml`,`Gopkg.lock`和`vendor/`.

求解器返回一个解决方案,该解决方案本身就是[表示法](https://godoc.org/github.com/golang/dep/gps#Solution)属于[存储在A中的数据`Gopkg.lock`](https://godoc.org/github.com/golang/dep#Lock)是整个依赖图的传递完整、可再现的快照.写出`Gopkg.lock`从一个解决方案只不过是一个复制和编码操作,和写作`vendor/`将指定的解决方案中列出的每一个项目放到指定的修订中.这完全一样.`dep ensure`的行为.

`Gopkg.toml`有点不同.不能保证为项目的所有依赖(甚至任何)推断出规则,但我们仍然希望填充.`Gopkg.toml`有理智的价值观.因此,对于未推断规则的任何依赖项,dep检查解决方案以查看最终选择了什么版本,并基于此创建约束:

-   如果一个分支,像`master`在解决方案中被选中`branch: "master"`将出现在`Gopkg.toml`.
-   如果选择了符合语义版本的版本,则`v1.2.0`,然后将指定为最小版本:`version: "v1.2.0"`.
-   如果只选择原始修订版,则没有任何内容.`Gopkg.toml`. 而DEP确实允许`revision: "…"`约束条件`Gopkg.toml`因为使用它们被认为是反模式,所以dep不会自动创建它们,以避免隐含地鼓励使用它们.

## 处理失败

首先,确保你在跑步.`dep init`与`-v`旗帜.这将提供更多的信息.

`dep init`与DEP一般一样,它既有硬模式又有软故障模式.硬故障导致进程挂起或完全中止,而没有任何东西写入磁盘.软故障可能包括或不包括警告,但最终写入`Gopkg.toml`,`Gopkg.lock`和`vendor/`-只是,不是你想要的在我们深入研究这些内容之前,让我们来设置一些上下文.

虽然dep贡献者已经投入了巨大的努力来创建到dep的自动迁移路径,但是这些路径总是尽力而为并且不精确.从其他工具或GopaTM转换为完全保真并不总是可能的.dep是一个自以为是的工具,具有相应的自以为是的模型,并且该模型有时确实与其他工具有根本的不同.有时这些模型不匹配导致硬故障,有时是软的,有时根本没有坏处.

因为这些都是深层次的假设,他们的症状可以是多样的和令人惊讶的.记住这些假设可以帮你节省一些时间.

-   DEP不允许嵌套`vendor/`目录;它将所有依赖项压缩到最顶层.`vendor/`目录,在项目的根目录下.这是DEP模型的基础,不能被禁用.
-   整体控制`vendor`并且将吹走任何偏离其上游源DEP选择的手动更改或添加.
-   DEP要求来自给定项目/仓库的所有包都在同一版本.
-   dep通常不关心GOPATH上的内容;它只处理源自远程网络位置的项目.(提示推断是唯一的例外;一旦解决开始,GOPATH——以及您对代码所做的任何自定义更改——将被忽略.)
-   DEP通常倾向于语义版本标记的发布到分支(当没有给出任何附加规则)时.这是从"默认分支"模型的重大转变.`go get`还有其他一些工具.它可以导致DEP做出对其无法推断规则的依赖性的令人惊讶的选择.
-   DEP假定所有生成的代码都存在,并且已经提交给源.

迄今为止,很少有项目能够找到一种合理的方法来适应这些要求.如果你不能想出如何使你的项目适合,请提交一个问题-虽然dep必然不能适应每一个现有的方法,它的目标是定义规则,所有的Go项目可以合理地适应.

### 硬故障

所有的硬故障模式在参考文献中被广泛地覆盖.[失效模式](failure-modes.md).

因为求解器及其所有可能的故障都是相同的.`dep init`至于`dep ensure`有一个单独的部分来理解和处理它们:[解决故障处理](failure-modes.md#solving-failures). 这可能更棘手.`dep init`然而,由于许多补救措施需要调整.`Gopkg.toml`.

不幸的是,`dep init`不写一部分`Gopkg.toml`当它失败时.这是一个已知的、关键的问题,[我们有一个开放的问题(需要帮助!)](https://github.com/golang/dep/issues/909).

同时,如果您遇到的特定错误确实需要`Gopkg.toml`调整一下,不幸的是,如果没有自动化`dep init`创建一个空[`Gopkg.toml`](Gopkg.toml.md)并用手工填充规则.在诉诸之前,确保你已经跑了`dep init`具有推断标志的各种组合(`-skip-tools`和`-gopath`看看他们能不能给你点东西.

### 软故障

软故障就是这样的情况`dep init`似乎干净地退出,但随后`go build`或`go test`失败.DEP的软故障通常比细微错误大得多,例如,当您尝试构建时,类型错误发生爆炸,因为选择了一些依赖性的错误版本.

如果你遇到这样的问题,`dep status`是您的第一个诊断步骤;它将报告为您的所有依赖项选择了哪些版本.很显然,依赖关系仅仅是从构建或测试错误消息中产生的问题.如果没有,比较`dep status`列出与前一个工具记录的版本,找出差异.

一旦确定了有问题的依赖关系,下一步就是对它们进行适当的控制.`Gopkg.toml`.

对于下面的每一项,假设您应该运行`dep ensure`在提出建议的改变之后.如果失败,请教[解决故障处理](<>).

-   如果错了`[[constraint]]`被推断为你的直接依赖之一,改变它.然后,向DEP提交一个问题(请!)-而`dep init`可以选择省略约束,错误地转换一个被认为是一个错误.
-   如果您的传递依赖项位于错误的版本中,则定义`[[override]]`把它逼到你需要的版本.
    -   如果您需要的版本是特定的Git提交,那么最好手动更改`revision`在期望的散列中`Gopkg.lock`对于那个项目,然后放弃`version`或`branch`字段(如果有的话).
-   如果你的一个直接依赖是错误的版本并且没有`[[constraint]]`关于它`Gopkg.toml`然后,定义一个合适的.
    -   与传递依赖关系一样,如果需要的版本是特定的Git提交,则最好手动进行`Gopkg.lock`.

希望这些信息足以帮助您通过项目迁移到dep.如果没有,请随时提交问题,或者加入我们[Goffs松弛的卖方](https://gophers.slack.com/messages/C0M5YP9LN)寻求帮助!
